<!DOCTYPE html>
<html lang="lt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duomenų Struktūros ir Algoritmai</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f9;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        h1, h2, h3, h4 {
            color: #2c3e50;
        }
        h1 {
            text-align: center;
            margin-bottom: 20px;
        }
        h2 {
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
            margin-top: 30px;
        }
        nav {
            background: #2c3e50;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        nav ul {
            list-style: none;
            padding: 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        nav ul li {
            margin: 5px 10px;
        }
        nav ul li a {
            color: #fff;
            text-decoration: none;
            font-weight: bold;
        }
        nav ul li a:hover {
            text-decoration: underline;
        }
        pre, code {
            background: #f8f8f8;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }
        ul {
            padding-left: 20px;
        }
        .section {
            margin-bottom: 30px;
        }
        .code-block {
            margin: 10px 0;
        }
        a {
            color: #3498db;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .note {
            background: #e8f4f8;
            border-left: 4px solid #3498db;
            padding: 10px;
            margin: 10px 0;
        }
        .example {
            background: #fff3e6;
            border-left: 4px solid #e67e22;
            padding: 10px;
            margin: 10px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 8px;
            text-align: left;
        }
        th {
            background: #3498db;
            color: #fff;
        }
        tr:nth-child(even) {
            background: #f8f8f8;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Duomenų Struktūros ir Algoritmai</h1>
        <nav>
            <ul>
                <li><a href="#medziai">Medžiai</a></li>
                <li><a href="#bst">Dvejetainis Paieškos Medis</a></li>
                <li><a href="#avl">AVL Medis</a></li>
                <li><a href="#btree">B-Medis</a></li>
                <li><a href="#heap">Kuprinė</a></li>
                <li><a href="#grafai">Grafai</a></li>
                <li><a href="#hashing">Maišos Lentelės</a></li>
                <li><a href="#rusiavimas">Rūšiavimas</a></li>
                <li><a href="#kiti">Kiti Algoritmai</a></li>
            </ul>
        </nav>

        <div id="medziai" class="section">
            <h2>Medžiai</h2>
            <p>Medžiai yra nelinijinės duomenų struktūros su hierarchine organizacija, idealiai tinkamos greitai paieškai ir hierarchinių duomenų atvaizdavimui.</p>
            <h3>Savybės</h3>
            <ul>
                <li><strong>Šaknis:</strong> Viršutinis mazgas be įeinančių briaunų.</li>
                <li><strong>Tėvas ir Vaikas:</strong> Kiekvienas mazgas (išskyrus šaknį) turi vieną tėvą ir gali turėti kelis vaikus.</li>
                <li><strong>Pomedis:</strong> Medis, sudarytas iš mazgo ir jo palikuonių.</li>
                <li><strong>Lapas:</strong> Mazgas be vaikų.</li>
                <li><strong>Kelias:</strong> Mazgų seka, kur kiekviena gretima pora sujungta briauna.</li>
            </ul>
            <h3>Dvejetainis Medis</h3>
            <p>Dvejetainis medis yra medis, kuriame kiekvienas mazgas turi ne daugiau kaip du vaikus (kairįjį ir dešinįjį).</p>
            <ul>
                <li><strong>Aukštis:</strong> Ilgiausio kelio nuo šaknies iki lapo ilgis.</li>
                <li><strong>Gylis:</strong> Kelio nuo šaknies iki mazgo ilgis.</li>
                <li><strong>Apėjimai:</strong>
                    <ul>
                        <li>Išankstinis (Šaknis, Kairė, Dešinė)</li>
                        <li>Vidinis (Kairė, Šaknis, Dešinė)</li>
                        <li>Atgalinis (Kairė, Dešinė, Šaknis)</li>
                    </ul>
                </li>
            </ul>
            <div class="example">
                <p><strong>Pavyzdys:</strong> Dvejetainiam mediui su šaknimi A, kairiuoju vaiku B (su vaikais D, E) ir dešiniuoju vaiku C (su vaikais F, G, H, I):</p>
                <ul>
                    <li>Išankstinis: A, B, D, E, C, F, G, H, I</li>
                    <li>Vidinis: D, B, E, A, F, C, G, H, I</li>
                    <li>Atgalinis: D, E, B, F, G, H, I, C, A</li>
                </ul>
            </div>
        </div>

        <div id="bst" class="section">
            <h2>Dvejetainis Paieškos Medis (BST)</h2>
            <p>Dvejetainis paieškos medis yra dvejetainis medis, kuriame kairysis pomedis turi mažesnes reikšmes nei mazgas, o dešinysis pomedis turi didesnes arba lygias mazgo reikšmes.</p>
            <h3>Savybės</h3>
            <ul>
                <li>Kairiojo pomedžio reikšmės < mazgo reikšmė.</li>
                <li>Dešiniojo pomedžio reikšmės ≥ mazgo reikšmė.</li>
                <li>Kiekvienas pomedis yra BST.</li>
            </ul>
            <h3>Operacijos</h3>
            <ul>
                <li><strong>Įterpimas:</strong> Rekursyviai įterpiama į kairįjį arba dešinįjį pomedį pagal reikšmės palyginimą.</li>
                <li><strong>Paieška:</strong> Palyginama su šaknimi, pereinama į kairįjį arba dešinįjį pomedį.</li>
                <li><strong>Šalinimas:</strong> Tvarkomi trys atvejai:
                    <ul>
                        <li>Lapas: Šalinamas tiesiogiai.</li>
                        <li>Vienas vaikas: Pakeičiamas vaiku.</li>
                        <li>Du vaikai: Pakeičiamas kairiojo pomedžio maksimumu, tada šalinamas tas mazgas.</li>
                    </ul>
                </li>
            </ul>
            <h3>Pavyzdinis Kodas (C)</h3>
            <pre class="code-block">
struct medis {
    int data; // Duomenys
    struct medis *kaire; // Kairysis vaikas
    struct medis *desine; // Dešinysis vaikas
};

struct medis* iterpti(struct medis *saknis, int x) {
    if (saknis == NULL) {
        struct medis *p = new medis;
        p->data = x;
        p->kaire = p->desine = NULL;
        return p;
    }
    if (x > saknis->data)
        saknis->desine = iterpti(saknis->desine, x);
    else
        saknis->kaire = iterpti(saknis->kaire, x);
    return saknis;
}

struct medis* panaikinti(struct medis *saknis, int x) {
    if (saknis == NULL) return NULL;
    if (x > saknis->data)
        saknis->desine = panaikinti(saknis->desine, x);
    else if (x < saknis->data)
        saknis->kaire = panaikinti(saknis->kaire, x);
    else {
        if (saknis->kaire == NULL && saknis->desine == NULL) {
            free(saknis);
            return NULL;
        }
        else if (saknis->kaire == NULL || saknis->desine == NULL) {
            struct medis *temp = saknis->kaire ? saknis->kaire : saknis->desine;
            free(saknis);
            return temp;
        }
        else {
            struct medis *temp = rasti_max(saknis->kaire);
            saknis->data = temp->data;
            saknis->kaire = panaikinti(saknis->kaire, temp->data);
        }
    }
    return saknis;
}
            </pre>
            <div class="note">
                <p>Vidinis BST apėjimas pateikia reikšmes surūšiuota tvarka.</p>
            </div>
        </div>

        <div id="avl" class="section">
            <h2>AVL Medis</h2>
            <p>AVL medis yra savibalansuojantis BST, kuriame kairiojo ir dešiniojo pomedžių aukščių skirtumas (balanso faktorius) neviršija 1, užtikrinant O(log n) operacijų sudėtingumą.</p>
            <h3>Balanso Faktorius (BF)</h3>
            <p>BF = kairiojo pomedžio aukštis - dešiniojo pomedžio aukštis. Galimos reikšmės: -1, 0, 1.</p>
            <h3>Rotacijos</h3>
            <ul>
                <li><strong>Dešininė Rotacija:</strong> BF = 2, kairiojo vaiko BF = 1.</li>
                <li><strong>Kairinė Rotacija:</strong> BF = -2, dešiniojo vaiko BF = -1.</li>
                <li><strong>Dešininė-Kairinė Rotacija:</strong> BF = -2, dešiniojo vaiko BF = 1.</li>
                <li><strong>Kairinė-Dešininė Rotacija:</strong> BF = 2, kairiojo vaiko BF = -1.</li>
            </ul>
            <h3>Operacijos</h3>
            <ul>
                <li><strong>Įterpimas:</strong> Įterpiama kaip BST, atnaujinami aukščiai, subalansuojama rotacijomis.</li>
                <li><strong>Šalinimas:</strong> Šalinama kaip BST, atnaujinami aukščiai, subalansuojama.</li>
            </ul>
            <h3>Pavyzdinis Kodas (C)</h3>
            <pre class="code-block">
struct Medis {
    int key; // Raktas
    struct Medis *Kaire; // Kairysis vaikas
    struct Medis *Desine; // Dešinysis vaikas
    int dydis; // Aukštis
};

int BalansinisKoef(struct Medis *N) {
    if (N == NULL) return 0;
    return RastiDydi(N->Kaire) - RastiDydi(N->Desine);
}

struct Medis *DesinePosukis(struct Medis *y) {
    struct Medis *x = y->Kaire;
    struct Medis *T2 = x->Desine;
    x->Desine = y;
    y->Kaire = T2;
    y->dydis = max(RastiDydi(y->Kaire), RastiDydi(y->Desine)) + 1;
    x->dydis = max(RastiDydi(x->Kaire), RastiDydi(x->Desine)) + 1;
    return x;
}

struct Medis *IterptiElementa(struct Medis *Medis, int key) {
    if (Medis == NULL) return NaujasElementas(key);
    if (key < Medis->key)
        Medis->Kaire = IterptiElementa(Medis->Kaire, key);
    else if (key > Medis->key)
        Medis->Desine = IterptiElementa(Medis->Desine, key);
    else return Medis;
    Medis->dydis = 1 + max(RastiDydi(Medis->Kaire), RastiDydi(Medis->Desine));
    int Balansas = BalansinisKoef(Medis);
    if (Balansas > 1 && key < Medis->Kaire->key) return DesinePosukis(Medis);
    if (Balansas < -1 && key > Medis->Desine->key) return KairePosukis(Medis);
    if (Balansas > 1 && key > Medis->Kaire->key) {
        Medis->Kaire = KairePosukis(Medis->Kaire);
        return DesinePosukis(Medis);
    }
    if (Balansas < -1 && key < Medis->Desine->key) {
        Medis->Desine = DesinePosukis(Medis->Desine);
        return KairePosukis(Medis);
    }
    return Medis;
}
            </pre>
        </div>

        <div id="btree" class="section">
            <h2>B-Medis</h2>
            <p>B-medis yra savibalansuojantis medis, skirtas disko saugykloms, leidžiantis mazgams turėti kelis vaikus (iki m m-tos eilės B-medyje), sumažindamas disko I/O.</p>
            <h3>Savybės</h3>
            <ul>
                <li>Ne lapiniai mazgai turi vienu raktu mažiau nei vaikų.</li>
                <li>Visi lapai yra tame pačiame lygyje.</li>
                <li>Ne šakniniai mazgai turi bent ⌈m/2⌉ vaikų.</li>
                <li>Šaknis turi nuo 2 iki m vaikų arba yra lapas.</li>
                <li>Mazgai turi daugiausia m-1 raktų.</li>
            </ul>
            <h3>Operacijos</h3>
            <ul>
                <li><strong>Įterpimas:</strong> Įterpiama į lapą, dalijami mazgai, jei viršijami m-1 raktai.</li>
                <li><strong>Šalinimas:</strong> Šalinamas raktas, skolinamasi iš kaimynų arba sujungiami mazgai, jei yra nepakankamai raktų.</li>
            </ul>
            <h3>Pavyzdinis Kodas (C)</h3>
            <pre class="code-block">
#define MAX 3
struct BTreeNode {
    int val[MAX + 1], count; // Raktai ir jų skaičius
    struct BTreeNode *link[MAX + 1]; // Nuorodos į vaikus
};

struct BTreeNode *createNode(int val, struct BTreeNode *child) {
    struct BTreeNode *newNode = new BTreeNode();
    newNode->val[1] = val;
    newNode->count = 1;
    newNode->link[0] = root;
    newNode->link[1] = child;
    return newNode;
}

void insertNode(int val, int pos, struct BTreeNode *node, struct BTreeNode *child) {
    int j = node->count;
    while (j > pos) {
        node->val[j + 1] = node->val[j];
        node->link[j + 1] = node->link[j];
        j--;
    }
    node->val[j + 1] = val;
    node->link[j + 1] = child;
    node->count++;
}
            </pre>
            <p class="note">B-medžiai plačiai naudojami duomenų bazėse ir failų sistemose dėl jų efektyvumo su dideliais duomenų rinkiniais.</p>
            <p>Išbandykite B-medžio vizualizaciją: <a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html" target="_blank">B-Medžio Vizualizacija</a></p>
        </div>

        <div id="heap" class="section">
            <h2>Kuprinė (Dvejetainė Kuprinė)</h2>
            <p>Dvejetainė kuprinė yra pilnas dvejetainis medis, kuriame kiekvieno mazgo vaikai yra mažesni arba lygūs (maksimali kuprinė) arba didesni arba lygūs (minimali kuprinė) mazgui, dažnai saugoma kaip masyvas.</p>
            <h3>Savybės</h3>
            <ul>
                <li>Pilnas medis: Užpildomas pagal lygius, iš kairės į dešinę.</li>
                <li>Kuprinės savybė: Tėvas ≥ vaikai (maksimali kuprinė) arba tėvas ≤ vaikai (minimali kuprinė).</li>
                <li>Masyvo atvaizdavimas: Šaknis yra A[1], A[i] vaikai yra A[2i], A[2i+1], tėvas yra A[⌊i/2⌋].</li>
            </ul>
            <h3>Operacijos</h3>
            <ul>
                <li><strong>Įterpimas:</strong> Pridedama prie galo, kyla aukštyn keičiant vietomis su tėvu.</li>
                <li><strong>Min/Max Šalinimas:</strong> Šalinama šaknis, pakeičiama paskutiniu elementu, subalansuojama žemyn.</li>
                <li><strong>Kuprinės Sukūrimas:</strong> Balansuojami mazgai nuo paskutinio ne lapo iki šaknies.</li>
            </ul>
            <h3>Pavyzdinis Kodas (C)</h3>
            <pre class="code-block">
int heap[1000000], heapSize; // Kuprinė ir jos dydis

void Insert(int element) {
    heapSize++;
    heap[heapSize] = element;
    int now = heapSize;
    while (heap[now / 2] > element) {
        heap[now] = heap[now / 2];
        now /= 2;
    }
    heap[now] = element;
}

int DeleteMin() {
    int minElement = heap[1], lastElement = heap[heapSize--], child, now;
    for (now = 1; now * 2 <= heapSize; now = child) {
        child = now * 2;
        if (child != heapSize && heap[child + 1] < heap[child]) child++;
        if (lastElement > heap[child]) heap[now] = heap[child];
        else break;
    }
    heap[now] = lastElement;
    return minElement;
}
            </pre>
            <div class="note">Kuprinės naudojamos prioritetinėse eilėse ir kuprinės rūšiavimo algoritmuose.</div>
        </div>

        <div id="grafai" class="section">
            <h2>Grafai</h2>
            <p>Grafas yra duomenų struktūra, sudaryta iš viršūnių (mazgų) ir briaunų (jungčių tarp mazgų), naudojama ryšiams modeliuoti.</p>
            <h3>Tipai</h3>
            <ul>
                <li><strong>Kryptiniai vs. Nekryptiniai:</strong> Kryptiniuose grafuose briaunos yra kryptingos (lankai); nekryptiniuose briaunos yra be krypties.</li>
                <li><strong>Svertiniai vs. Nesvertiniai:</strong> Svertiniuose grafuose briaunoms priskiriamos reikšmės (pvz., atstumai).</li>
                <li><strong>Cikliniai vs. Acikliniai:</strong> Cikliniuose grafuose yra ciklai; acikliniuose jų nėra.</li>
            </ul>
            <h3>Atvaizdavimai</h3>
            <ul>
                <li><strong>Gretimumo Matrica:</strong> 2D masyvas, kuriame matrica[i][j] rodo briauną iš i į j.</li>
                <li><strong>Gretimumo Sąrašas:</strong> Kiekviena viršūnė saugo gretimų viršūnių sąrašą.</li>
            </ul>
            <h3>Apėjimai</h3>
            <ul>
                <li><strong>Gylio Pirmenybės Paieška (DFS):</strong> Tyrinėja kuo toliau palei kiekvieną šaką prieš grįždama atgal.</li>
                <li><strong>Platumo Pirmenybės Paieška (BFS):</strong> Tyrinėja visus kaimynus esamame gylyje prieš pereidama giliau.</li>
            </ul>
            <h3>Pavyzdinis Kodas (C, Gretimumo Sąrašas)</h3>
            <pre class="code-block">
#include <stdio.h>
#include <stdlib.h>
#define MAX 100

struct Node {
    int vertex; // Viršūnė
    struct Node* next; // Kitas mazgas
};

struct Graph {
    int V; // Viršūnių skaičius
    struct Node** adjList; // Gretimumo sąrašas
};

struct Graph* createGraph(int V) {
    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
    graph->V = V;
    graph->adjList = (struct Node**)malloc(V * sizeof(struct Node*));
    for (int i = 0; i < V; i++) graph->adjList[i] = NULL;
    return graph;
}

void addEdge(struct Graph* graph, int src, int dest) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->vertex = dest;
    newNode->next = graph->adjList[src];
    graph->adjList[src] = newNode;
}
            </pre>
            <h3>Algoritmai</h3>
            <ul>
                <li><strong>Dijkstra Algoritmas:</strong> Randa trumpiausius kelius svertiniuose grafuose su neneigiamais svoriais.</li>
                <li><strong>Kruskal Algoritmas:</strong> Randa minimalųjį dengiantį medį naudojant godųjį metodą.</li>
            </ul>
        </div>

        <div id="hashing" class="section">
            <h2>Maišos Lentelės</h2>
            <p>Maišos lentelės susieja duomenis su fiksuoto dydžio lentele naudodamos maišos funkciją, užtikrindamos O(1) vidutinį prieigos laiką.</p>
            <h3>Maišos Funkcija</h3>
            <p>Funkcija, kuri konvertuoja raktą į lentelės indeksą. Pavyzdys: h(k) = k mod m.</p>
            <h3>Kolizijų Sprendimas</h3>
            <ul>
                <li><strong>Grandininis Metodas:</strong> Saugo susiduriančius elementus sąraše tame pačiame indekse.</li>
                <li><strong>Atviras Adresavimas:</strong> Randa kitą laisvą vietą naudojant zondavimą (linijinį, kvadratinį, dvigubą maišos).</li>
            </ul>
            <h3>Pavyzdinis Kodas (C, Grandininis Metodas)</h3>
            <pre class="code-block">
#include <stdio.h>
#include <stdlib.h>
#define SIZE 10

struct Node {
    int data; // Duomenys
    struct Node* next; // Kitas mazgas
};

struct HashTable {
    struct Node* table[SIZE]; // Maišos lentelė
};

struct HashTable* createHashTable() {
    struct HashTable* ht = (struct HashTable*)malloc(sizeof(struct HashTable));
    for (int i = 0; i < SIZE; i++) ht->table[i] = NULL;
    return ht;
}

void insert(struct HashTable* ht, int key) {
    int index = key % SIZE;
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = key;
    newNode->next = ht->table[index];
    ht->table[index] = newNode;
}
            </pre>
            <div class="example">
                <p><strong>Pavyzdys:</strong> Įterpkite raktus 15, 25, 35 į maišos lentelę, kurios dydis 10 (h(k) = k mod 10). Visi susieta į indeksą 5, sudarydami sąrašą: 35 -> 25 -> 15.</p>
            </div>
        </div>

        <div id="rusiavimas" class="section">
            <h2>Rūšiavimo Algoritmai</h2>
            <p>Rūšiavimas išdėsto elementus tam tikra tvarka (pvz., didėjančia ar mažėjančia). Spartieji rūšiavimo algoritmai naudoja skaldyk ir valdyk strategiją, pasiekdami optimalų O(n log n) sudėtingumą, skirtingai nuo lėtesnių O(n²) algoritmų.</p>
            <h3>Palyginimas</h3>
            <table>
                <tr>
                    <th>Algoritmas</th>
                    <th>Laiko Sudėtingumas (Geriausias)</th>
                    <th>Laiko Sudėtingumas (Vidutinis)</th>
                    <th>Laiko Sudėtingumas (Blogiausias)</th>
                    <th>Vietos Sudėtingumas</th>
                    <th>Stabilus</th>
                </tr>
                <tr>
                    <td>Burbulo Rūšiavimas</td>
                    <td>O(n)</td>
                    <td>O(n²)</td>
                    <td>O(n²)</td>
                    <td>O(1)</td>
                    <td>Taip</td>
                </tr>
                <tr>
                    <td>Išrinkimo Rūšiavimas</td>
                    <td>O(n²)</td>
                    <td>O(n²)</td>
                    <td>O(n²)</td>
                    <td>O(1)</td>
                    <td>Ne</td>
                </tr>
                <tr>
                    <td>Įterpimo Rūšiavimas</td>
                    <td>O(n)</td>
                    <td>O(n²)</td>
                    <td>O(n²)</td>
                    <td>O(1)</td>
                    <td>Taip</td>
                </tr>
                <tr>
                    <td>Suliejimo Rūšiavimas</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                    <td>O(n)</td>
                    <td>Taip</td>
                </tr>
                <tr>
                    <td>Spartusis Rūšiavimas</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                    <td>O(n²)</td>
                    <td>O(log n)</td>
                    <td>Ne</td>
                </tr>
                <tr>
                    <td>Kuprinės Rūšiavimas</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                    <td>O(1)</td>
                    <td>Ne</td>
                </tr>
                <tr>
                    <td>Šelo Rūšiavimas</td>
                    <td>O(n log n)</td>
                    <td>O(n^(4/3))</td>
                    <td>O(n^(3/2))</td>
                    <td>O(1)</td>
                    <td>Ne</td>
                </tr>
                <tr>
                    <td>Radix Rūšiavimas</td>
                    <td>O(nk)</td>
                    <td>O(nk)</td>
                    <td>O(nk)</td>
                    <td>O(n + k)</td>
                    <td>Taip</td>
                </tr>
            </table>
            <h3>Spartieji Rūšiavimo Algoritmai</h3>
            <h4>Spartusis Rūšiavimas (QuickSort)</h4>
            <p>Spartusis rūšiavimas naudoja skaldyk ir valdyk metodą, pasirinkdamas pagrindinį elementą (pvz., vidurinį, atsitiktinį ar kraštinį), kad padalintų masyvą į poaibius su elementais, mažesniais ir didesniais už pagrindinį. Poaibiai rūšiuojami rekursyviai. Pagrindinio elemento pasirinkimas įtakoja efektyvumą; prastas pasirinkimas (pvz., pirmasis elementas surūšiuotame masyve) sukelia O(n²) blogiausio atvejo sudėtingumą.</p>
            <div class="example">
                <p><strong>Pavyzdys:</strong> Masyvui [15, 10, 33], pasirinkite pagrindinį elementą 15. Padalinkite į [10] (mažesnis už 15), [15] ir [33] (didesnis už 15). Rekursyviai rūšiuokite poaibius, gaunant [10, 15, 33].</p>
            </div>
            <h3>Pavyzdinis Kodas (C, Spartusis Rūšiavimas)</h3>
            <pre class="code-block">
void quickSort(int arr[], int left, int right) {
    int i = left, j = right;
    int tmp;
    int pivot = arr[(left + right) / 2]; // Pagrindinis elementas
    while (i <= j) {
        while (arr[i] < pivot) i++;
        while (arr[j] > pivot) j--;
        if (i <= j) {
            tmp = arr[i];
            arr[i] = arr[j];
            arr[j] = tmp;
            i++;
            j--;
        }
    }
    if (left < j) quickSort(arr, left, j);
    if (i < right) quickSort(arr, i, right);
}
            </pre>
            <h4>Suliejimo Rūšiavimas (MergeSort)</h4>
            <p>Suliejimo rūšiavimas, išrastas John von Neumann 1945 m., dalija masyvą į dvi dalis, rekursyviai jas rūšiuoja ir sujungia surūšiuotas dalis. Jis garantuoja O(n log n) sudėtingumą net blogiausiu atveju, bet reikalauja O(n) papildomos vietos sujungimui.</p>
            <div class="example">
                <p><strong>Pavyzdys:</strong> Masyvui [65, 72, 105, 55, 2], padalinkite į [65, 72] ir [105, 55, 2]. Rekursyviai rūšiuokite į [65, 72] ir [2, 55, 105], tada sujunkite į [2, 55, 65, 72, 105].</p>
            </div>
            <h3>Pavyzdinis Kodas (C, Suliejimo Rūšiavimas)</h3>
            <pre class="code-block">
void mergeSort(int numbers[], int temp[], int array_size) {
    m_sort(numbers, temp, 0, array_size - 1);
}

void m_sort(int numbers[], int temp[], int left, int right) {
    int mid;
    if (right > left) {
        mid = (right + left) / 2;
        m_sort(numbers, temp, left, mid);
        m_sort(numbers, temp, mid + 1, right);
        merge(numbers, temp, left, mid + 1, right);
    }
}

void merge(int numbers[], int temp[], int left, int mid, int right) {
    int i, left_end, num_elements, tmp_pos;
    left_end = mid - 1;
    tmp_pos = left;
    num_elements = right - left + 1;
    while ((left <= left_end) && (mid <= right)) {
        if (numbers[left] <= numbers[mid]) {
            temp[tmp_pos++] = numbers[left++];
        } else {
            temp[tmp_pos++] = numbers[mid++];
        }
    }
    while (left <= left_end) {
        temp[tmp_pos++] = numbers[left++];
    }
    while (mid <= right) {
        temp[tmp_pos++] = numbers[mid++];
    }
    for (i = 0; i < num_elements; i++) {
        numbers[right] = temp[right];
        right--;
    }
}
            </pre>
            <h4>Šelo Rūšiavimas (ShellSort)</h4>
            <p>Šelo rūšiavimas, sukurtas D.L. Shell, pagerina įterpimo rūšiavimą, rūšiuodamas elementus dideliais tarpais, kurie mažėja, kol masyvas tampa beveik surūšiuotas, tada atliekamas galutinis įterpimo rūšiavimas. Tarpo seka įtakoja efektyvumą; tipinis blogiausio atvejo sudėtingumas yra O(n^(3/2)).</p>
            <div class="example">
                <p><strong>Pavyzdys:</strong> 16 elementų masyvui pradinis tarpas = 8, rūšiuojamos poros {0,8}, {1,9} ir t.t. Sumažinkite tarpą iki 4, tada 2, tada 1, kiekviename žingsnyje taikydami įterpimo rūšiavimą.</p>
            </div>
            <h3>Pavyzdinis Kodas (C, Šelo Rūšiavimas)</h3>
            <pre class="code-block">
void ShellSort(int array[], int length) {
    int i, temp, flag = 1;
    int d = length;
    while (flag || (d > 1)) {
        flag = 0;
        d = (d + 1) / 2; // Tarpas
        for (i = 0; i < (length - d); i++) {
            if (array[i + d] < array[i]) {
                temp = array[i + d];
                array[i + d] = array[i];
                array[i] = temp;
                flag = 1;
            }
        }
    }
}
            </pre>
            <h4>Kuprinės Rūšiavimas (HeapSort)</h4>
            <p>Kuprinės rūšiavimas naudoja dvejetainę kuprinę elementams rūšiuoti. Sukuriama maksimali kuprinė, pakartotinai išimamas didžiausias elementas ir dedamas į galą, mažinant kuprinės dydį. Algoritmas yra vietinis, bet nestabilus.</p>
            <h4>Radix Rūšiavimas</h4>
            <p>Radix rūšiavimas apdoroja skaitmenis nuo mažiausiai iki labiausiai reikšmingo, naudodamas stabilų rūšiavimo algoritmą (pvz., skaičiavimo rūšiavimą) kiekvienam skaitmeniui. Sudėtingumas yra O(nk), kur k yra skaitmenų skaičius.</p>
            <h3>Pavyzdinis Kodas (C, Radix Rūšiavimas)</h3>
            <pre class="code-block">
void radixSort(int arr[], int n) {
    int max = getMax(arr, n); // Randa maksimalų elementą
    for (int exp = 1; max / exp > 0; exp *= 10)
        countingSort(arr, n, exp); // Skaičiavimo rūšiavimas
}
            </pre>
            <div class="note">Spartieji rūšiavimo algoritmai, tokie kaip spartusis ir suliejimo rūšiavimas, yra plačiai naudojami praktikoje dėl jų efektyvumo, o Šelo ir Radix rūšiavimas siūlo unikalius privalumus specifiniams duomenų tipams.</div>
        </div>

        <div id="kiti" class="section">
            <h2>Kiti Algoritmai</h2>
            <h3>Dvejetainė Paieška</h3>
            <p>Dvejetainė paieška veikia su surūšiuotu masyvu, pakartotinai dalindama paieškos intervalą per pusę. Ji lygina vidurinį elementą su tikslu, siaurindama paiešką į kairę arba dešinę pusę. Pasiekia O(log n) laiko sudėtingumą.</p>
            <div class="example">
                <p><strong>Pavyzdys:</strong> Norint rasti 99 surūšiuotame masyve nuo 1 iki 100, pradėkite nuo 50 (per mažas), tada 75 (per mažas), tada 88 ir t.t., reikalaujant daugiausia 7 žingsnių.</p>
            </div>
            <h3>Pavyzdinis Kodas (C, Dvejetainė Paieška)</h3>
            <pre class="code-block">
int binarySearch(int array[], int x, int low, int high) {
    while (low <= high) {
        int mid = low + (high - low) / 2; // Vidurinis indeksas
        if (array[mid] == x)
            return mid;
        if (array[mid] < x)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return -1; // Nerasta
}
            </pre>
            <h3>Burbulo Rūšiavimas</h3>
            <p>Burbulo rūšiavimas pakartotinai lygina gretimus elementus, keisdamas juos vietomis, jei jie yra netinkama tvarka, kol nebereikia keitimų. Jis yra stabilus, bet lėtas, su O(n²) sudėtingumu.</p>
            <h3>Pavyzdinis Kodas (C, Burbulo Rūšiavimas)</h3>
            <pre class="code-block">
void Bubble_Sort(int array[], int length) {
    int i, j, flag = 1; // Vėliava, ar buvo keitimų
    int temp;
    for (i = 0; (i < length - 1) && flag; i++) {
        flag = 0;
        for (j = 0; j < (length - i - 1); j++) {
            if (array[j + 1] > array[j]) {
                temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
                flag = 1;
            }
        }
    }
}
            </pre>
            <h3>Įterpimo Rūšiavimas</h3>
            <p>Įterpimo rūšiavimas kuria surūšiuotą masyvą, įterpdamas kiekvieną elementą į teisingą vietą tarp anksčiau surūšiuotų elementų. Jis yra stabilus ir efektyvus mažiems ar beveik surūšiuotiems masyvams, su O(n²) sudėtingumu.</p>
            <h3>Pavyzdinis Kodas (C, Įterpimo Rūšiavimas)</h3>
            <pre class="code-block">
void insertion_Sort(int *array, int length) {
    int i, j, tmp;
    for (i = 1; i < length; i++) {
        j = i;
        while (j > 0 && (array[j - 1] > array[j])) {
            tmp = array[j];
            array[j] = array[j - 1];
            array[j - 1] = tmp;
            j--;
        }
    }
}
            </pre>
            <h3>Išrinkimo Rūšiavimas</h3>
            <p>Išrinkimo rūšiavimas pakartotinai randa minimalų elementą iš nerūšiuotos dalies ir deda jį į pradžią. Jis nėra stabilus ir turi O(n²) sudėtingumą, bet sumažina keitimų skaičių.</p>
            <h3>Pavyzdinis Kodas (C, Išrinkimo Rūšiavimas)</h3>
            <pre class="code-block">
void Selection_Sort(int *array, int length) {
    if (length <= 1) return;
    for (int i = 0; i < length - 1; i++) {
        int iSmallest = i; // Mažiausio elemento indeksas
        for (int j = i + 1; j < length; j++) {
            if (array[iSmallest] > array[j])
                iSmallest = j;
        }
        int tmp = array[iSmallest];
        array[iSmallest] = array[i];
        array[i] = tmp;
    }
}
            </pre>
            <h3>Keliaujančio Pardavėjo Problema (TSP)</h3>
            <p>Keliaujančio pardavėjo problema ieško trumpiausio maršruto, kad pardavėjas aplankytų n miestų ir grįžtų į pradinį tašką. Brute-force metodas turi O(n!) sudėtingumą, todėl yra neįmanomas dideliam n. Tai viena iš neišspręstų kompiuterių mokslo problemų.</p>
            <div class="example">
                <p><strong>Pavyzdys:</strong> 5 miestams yra 120 galimų maršrutų. 7 miestams yra 5040 maršrutų, iliustruojant faktorinį augimą.</p>
            </div>
            <div class="note">Dvejetainė paieška yra labai efektyvi surūšiuotiems duomenims, o lėtesni rūšiavimo algoritmai, tokie kaip burbulo, įterpimo ir išrinkimo rūšiavimas, yra paprastesni, bet mažiau praktiški dideliems duomenų rinkiniams. TSP pabrėžia kombinatorinių problemų iššūkius.</div>
        </div>

        <div class="section">
            <h2>Papildoma Informacija</h2>
            <p>Išbandykite vizualizacijas ir papildomus resursus:</p>
            <ul>
                <li><a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html" target="_blank">B-Medžio Vizualizacija</a></li>
                <li><a href="https://visualgo.net/en" target="_blank">VisuAlgo: Duomenų Struktūrų ir Algoritmų Vizualizacijos</a></li>
            </ul>
        </div>
    </div>
</body>
</html>